<!DOCTYPE html>
<html class="google" lang="en">
  <head>
    <meta charset="utf-8">
    <script>
    (function(H){H.className=H.className.replace(/\bgoogle\b/,'google-js')})(document.documentElement)
    </script>
    <meta content="initial-scale=1, minimum-scale=1, width=device-width" name="viewport">
    <title>
      Google - Site Reliability Engineering
    </title>
    <script src="../js/google.js">
    </script>
    <script>
    new gweb.analytics.AutoTrack({profile:"UA-75468017-1"});
    </script>
    <link href="../css/opensans.css" rel=
    "stylesheet">
    <link href="../css/main.min.css" rel="stylesheet">
    <link href=
    '../css/roboto.css'
    rel='stylesheet' type='text/css'>
    <link href="../../images/favicon.ico" rel="shortcut icon">
  </head>
  <body>
    <div class="menu-closed" id="curtain"></div>
    <div class="header clearfix">
      <div class="header-wrraper">
        <a class="expand" id="burger-menu"></a>
        <h2 class="chapter-title">
          Chapter 9 - Simplicity
        </h2>
      </div>
    </div>
    <div class="expands" id="overlay-element">
      <div class="logo">
        <a href="https://www.google.com"><img alt="Google" src=
        "../../images/googlelogo-grey-color.png"></a>
      </div>
      <ol class="dropdown-content hide" id="drop-down">
        <li>
          <a class="menu-buttons" href="../index.html">Table of Contents</a>
        </li>
        <li>
          <a class="menu-buttons" href="foreword.html">Foreword</a>
        </li>
        <li>
          <a class="menu-buttons" href="preface.html">Preface</a>
        </li>
        <li>
          <a class="menu-buttons" href="part1.html">Part I - Introduction</a>
        </li>
        <li>
          <a class="menu-buttons" href="introduction.html">1. Introduction</a>
        </li>
        <li>
          <a class="menu-buttons" href="production-environment.html">2. The
          Production Environment at Google, from the Viewpoint of an SRE</a>
        </li>
        <li>
          <a class="menu-buttons" href="part2.html">Part II - Principles</a>
        </li>
        <li>
          <a class="menu-buttons" href="embracing-risk.html">3. Embracing
          Risk</a>
        </li>
        <li>
          <a class="menu-buttons" href="service-level-objectives.html">4.
          Service Level Objectives</a>
        </li>
        <li>
          <a class="menu-buttons" href="eliminating-toil.html">5. Eliminating
          Toil</a>
        </li>
        <li>
          <a class="menu-buttons" href="monitoring-distributed-systems.html">6.
          Monitoring Distributed Systems</a>
        </li>
        <li>
          <a class="menu-buttons" href="automation-at-google.html">7. The
          Evolution of Automation at Google</a>
        </li>
        <li>
          <a class="menu-buttons" href="release-engineering.html">8. Release
          Engineering</a>
        </li>
        <li class='active'>
          <a class="menu-buttons" href="simplicity.html">9. Simplicity</a>
        </li>
        <li>
          <a class="menu-buttons" href="part3.html">Part III - Practices</a>
        </li>
        <li>
          <a class="menu-buttons" href="practical-alerting.html">10. Practical
          Alerting</a>
        </li>
        <li>
          <a class="menu-buttons" href="being-on-call.html">11. Being
          On-Call</a>
        </li>
        <li>
          <a class="menu-buttons" href="effective-troubleshooting.html">12.
          Effective Troubleshooting</a>
        </li>
        <li>
          <a class="menu-buttons" href="emergency-response.html">13. Emergency
          Response</a>
        </li>
        <li>
          <a class="menu-buttons" href="managing-incidents.html">14. Managing
          Incidents</a>
        </li>
        <li>
          <a class="menu-buttons" href="postmortem-culture.html">15. Postmortem
          Culture: Learning from Failure</a>
        </li>
        <li>
          <a class="menu-buttons" href="tracking-outages.html">16. Tracking
          Outages</a>
        </li>
        <li>
          <a class="menu-buttons" href="testing-reliability.html">17. Testing
          for Reliability</a>
        </li>
        <li>
          <a class="menu-buttons" href="software-engineering-in-sre.html">18.
          Software Engineering in SRE</a>
        </li>
        <li>
          <a class="menu-buttons" href="load-balancing-frontend.html">19. Load
          Balancing at the Frontend</a>
        </li>
        <li>
          <a class="menu-buttons" href="load-balancing-datacenter.html">20. Load
          Balancing in the Datacenter</a>
        </li>
        <li>
          <a class="menu-buttons" href="handling-overload.html">21. Handling
          Overload</a>
        </li>
        <li>
          <a class="menu-buttons" href="addressing-cascading-failures.html">22.
          Addressing Cascading Failures</a>
        </li>
        <li>
          <a class="menu-buttons" href="managing-critical-state.html">23.
          Managing Critical State: Distributed Consensus for Reliability</a>
        </li>
        <li>
          <a class="menu-buttons" href=
          "distributed-periodic-scheduling.html">24. Distributed Periodic
          Scheduling with Cron</a>
        </li>
        <li>
          <a class="menu-buttons" href="data-processing-pipelines.html">25. Data
          Processing Pipelines</a>
        </li>
        <li>
          <a class="menu-buttons" href="data-integrity.html">26. Data Integrity:
          What You Read Is What You Wrote</a>
        </li>
        <li>
          <a class="menu-buttons" href="reliable-product-launches.html">27.
          Reliable Product Launches at Scale</a>
        </li>
        <li>
          <a class="menu-buttons" href="part4.html">Part IV - Management</a>
        </li>
        <li>
          <a class="menu-buttons" href="accelerating-sre-on-call.html">28.
          Accelerating SREs to On-Call and Beyond</a>
        </li>
        <li>
          <a class="menu-buttons" href="dealing-with-interrupts.html">29.
          Dealing with Interrupts</a>
        </li>
        <li>
          <a class="menu-buttons" href="operational-overload.html">30. Embedding
          an SRE to Recover from Operational Overload</a>
        </li>
        <li>
          <a class="menu-buttons" href=
          "communication-and-collaboration.html">31. Communication and
          Collaboration in SRE</a>
        </li>
        <li>
          <a class="menu-buttons" href="evolving-sre-engagement-model.html">32.
          The Evolving SRE Engagement Model</a>
        </li>
        <li>
          <a class="menu-buttons" href="part5.html">Part V - Conclusions</a>
        </li>
        <li>
          <a class="menu-buttons" href="lessons-learned.html">33. Lessons
          Learned from Other Industries</a>
        </li>
        <li>
          <a class="menu-buttons" href="conclusion.html">34. Conclusion</a>
        </li>
        <li>
          <a class="menu-buttons" href="availability-table.html">Appendix A.
          Availability Table</a>
        </li>
        <li>
          <a class="menu-buttons" href="service-best-practices.html">Appendix B.
          A Collection of Best Practices for Production Services</a>
        </li>
        <li>
          <a class="menu-buttons" href="incident-document.html">Appendix C.
          Example Incident State Document</a>
        </li>
        <li>
          <a class="menu-buttons" href="postmortem.html">Appendix D. Example
          Postmortem</a>
        </li>
        <li>
          <a class="menu-buttons" href="launch-checklist.html">Appendix E.
          Launch Coordination Checklist</a>
        </li>
        <li>
          <a class="menu-buttons" href="bibliography.html">Appendix F.
          Bibliography</a>
        </li>
      </ol>
    </div>
    <div id="maia-main" role="main">
      <div class="maia-teleport" id="content"></div>
      <div class="content">
        <h1 class="heading">
          Simplicity
        </h1>
        <p class="byline author">
          Written by Max Luebbe<br>
          Edited by Tim Harvey
        </p>
        <blockquote>
          <p class="quote">
            The price of reliability is the pursuit of the utmost simplicity."
          </p>
          <p class="quote-author">
            C.A.R. Hoare, Turing Award lecture
          </p>
        </blockquote>
        <p>
          Software systems are inherently dynamic and unstable.<sup><a href="simplicity.html#id-BWDujIehq" id=
          "id-BWDujIehq-marker">38</a></sup> A software system can only be perfectly stable if it
          exists in a vacuum. If we stop changing the codebase, we stop introducing bugs. If the
          underlying hardware or libraries never change, neither of these components will introduce
          bugs. If we freeze the current user base, we’ll never have to scale the system. In fact,
          a good summary of the SRE approach to managing systems is: "At the end of the day, our
          job is to keep agility and stability in balance in the system."<sup><a href=
          "simplicity.html#id-MJbuJtOhb" id="id-MJbuJtOhb-marker">39</a></sup>
        </p>
        <h1 class="heading">
          System Stability Versus Agility
        </h1>
        <p>
          It sometimes makes sense to sacrifice stability for the sake of agility. I’ve often
          approached an unfamiliar problem domain by conducting what I call exploratory
          coding—setting an explicit shelf life for whatever code I write with the understanding
          that I’ll need to try and fail once in order to really understand the task I need to
          accomplish. Code that comes with an expiration date can be much more liberal with test
          coverage and release management because it will never be shipped to production or be seen
          by users.
        </p>
        <p>
          For the majority of production software systems, we want a balanced mix of stability and
          agility. SREs work to create procedures, practices, and tools that render software more
          reliable. At the same time, SREs ensure that this work has as little impact on developer
          agility as possible. In fact, SRE’s experience has found that reliable processes tend to
          actually increase developer agility: rapid, reliable production rollouts make changes in
          production easier to see. As a result, once a bug surfaces, it takes less time to find
          and fix that bug. Building reliability into development allows developers to focus their
          attention on what we really do care about—the functionality and performance of their
          software and systems.
        </p>
        <h1 class="heading">
          The Virtue of Boring
        </h1>
        <p>
          Unlike just about everything else in life, "boring" is actually a positive attribute when
          it comes to software! We don’t want our programs to be spontaneous and interesting; we
          want them to stick to the script and predictably accomplish their business goals. In the
          words of Google engineer Robert Muth, "Unlike a detective story, the lack of excitement,
          suspense, and puzzles is actually a desirable property of source code." Surprises in
          production are the nemeses of SRE.
        </p>
        <p>
          As Fred Brooks suggests in his "No Silver Bullet" essay <a href=
          "bibliography.html#Bro95" target="_blank">[Bro95]</a>, it is very
          important to consider the difference between essential complexity and accidental
          complexity. Essential complexity is the complexity inherent in a given situation that
          cannot be removed from a problem definition, whereas accidental complexity is more fluid
          and can be resolved with engineering effort. For example, writing a web server entails
          dealing with the essential complexity of serving web pages quickly. However, if we write
          a web server in Java, we may introduce accidental complexity when trying to minimize the
          performance impact of garbage collection.
        </p>
        <p>
          With an eye towards minimizing accidental complexity, SRE teams should:
        </p>
        <ul>
          <li>Push back when accidental complexity is introduced into the systems for which they
          are responsible
          </li>
          <li>Constantly strive to eliminate complexity in systems they onboard and for which they
          assume operational responsibility
          </li>
        </ul>
        <h1 class="heading">
          I Won’t Give Up My Code!
        </h1>
        <p>
          Because engineers are human beings who often form an emotional attachment to their
          creations, confrontations over large-scale purges of the source tree are not uncommon.
          Some might protest, "What if we need that code later?" "Why don’t we just comment the
          code out so we can easily add it again later?" or "Why don’t we gate the code with a flag
          instead of deleting it?" These are all terrible suggestions. Source control systems make
          it easy to reverse changes, whereas hundreds of lines of commented code create
          distractions and confusion (especially as the source files continue to evolve), and code
          that is never executed, gated by a flag that is always disabled, is a metaphorical time
          bomb waiting to explode, as painfully experienced by Knight Capital, for example (see
          "Order In the Matter of Knight Capital Americas LLC" <a href=
          "bibliography.html#Sec13" target="_blank">[Sec13]</a>).
        </p>
        <p>
          At the risk of sounding extreme, when you consider a web service that’s expected to be
          available 24/7, to some extent, every new line of code written is a liability. SRE
          promotes practices that make it more likely that all code has an essential purpose, such
          as scrutinizing code to make sure that it actually drives business goals, routinely
          removing dead code, and building bloat detection into all levels of testing.
        </p>
        <h1 class="heading">
          The "Negative Lines of Code" Metric
        </h1>
        <p>
          The term "software bloat" was coined to describe the tendency of software to become
          slower and bigger over time as a result of a constant stream of additional features.
          While bloated software seems intuitively undesirable, its negative aspects become even
          more clear when considered from the SRE perspective: every line of code changed or added
          to a project creates the potential for introducing new defects and bugs. A smaller
          project is easier to understand, easier to test, and frequently has fewer defects.
          Bearing this perspective in mind, we should perhaps entertain reservations when we have
          the urge to add new features to a project. Some of the most satisfying coding I’ve ever
          done was deleting thousands of lines of code at a time when it was no longer useful.
        </p>
        <h1 class="heading">
          Minimal APIs
        </h1>
        <p>
          French poet Antoine de Saint Exupery wrote, "perfection is finally attained not when
          there is no longer more to add, but when there is no longer anything to take away"
          <a href="bibliography.html#Sai39" target="_blank">[Sai39]</a>. This
          principle is also applicable to the design and construction of software. APIs are a
          particularly clear expression of why this rule should be followed.
        </p>
        <p>
          Writing clear, minimal APIs is an essential aspect of managing simplicity in a software
          system. The fewer methods and arguments we provide to consumers of the API, the easier
          that API will be to understand, and the more effort we can devote to making those methods
          as good as they can possibly be. Again, a recurring theme appears: the conscious decision
          to not take on certain problems allows us to focus on our core problem and make the
          solutions we explicitly set out to create substantially better. In software, less is
          more! A small, simple API is usually also a hallmark of a well-understood problem.
        </p>
        <h1 class="heading">
          Modularity
        </h1>
        <p>
          Expanding outward from APIs and single binaries, many of the rules of thumb that apply to
          object-oriented programming also apply to the design of distributed systems. The ability
          to make changes to parts of the system in isolation is essential to creating a
          supportable system. Specifically, loose coupling between binaries, or between binaries
          and configuration, is a simplicity pattern that simultaneously promotes developer agility
          and system stability. If a bug is discovered in one program that is a component of a
          larger system, that bug can be fixed and pushed to production independent of the rest of
          the system.
        </p>
        <p>
          While the modularity that APIs offer may seem straightforward, it is not so apparent that
          the notion of modularity also extends to how changes to APIs are introduced. Just a
          single change to an API can force developers to rebuild their entire system and run the
          risk of introducing new bugs. Versioning APIs allows developers to continue to use the
          version that their system depends upon while they upgrade to a newer version in a safe
          and considered way. The release cadence can vary throughout a system, instead of
          requiring a full production push of the entire system every time a feature is added or
          improved.
        </p>
        <p>
          As a system grows more complex, the separation of responsibility between APIs and between
          binaries becomes increasingly important. This is a direct analogy to object-oriented
          class design: just as it is understood that it is poor practice to write a "grab bag"
          class that contains unrelated functions, it is also poor practice to create and put into
          production a "util" or "misc" binary. A well-designed distributed system consists of
          collaborators, each of which has a clear and well-scoped purpose.
        </p>
        <p>
          The concept of modularity also applies to data formats. One of the central strengths and
          design goals of Google’s protocol buffers<sup><a href="simplicity.html#id-0vYuXSLhXCk" id=
          "id-0vYuXSLhXCk-marker">40</a></sup> was to create a wire format that was backward and
          forward compatible.
        </p>
        <h1 class="heading">
          Release Simplicity
        </h1>
        <p>
          Simple releases are generally better than complicated releases. It is much easier to
          measure and understand the impact of a single change rather than a batch of changes
          released simultaneously. If we release 100 unrelated changes to a system at the same time
          and performance gets worse, understanding which changes impacted performance, and how
          they did so, will take considerable effort or additional instrumentation. If the release
          is performed in smaller batches, we can move faster with more confidence because each
          code change can be understood in isolation in the larger system. This approach to
          releases can be compared to gradient descent in machine learning, in which we find an
          optimum solution by taking small steps at a time, and considering if each change results
          in an improvement or degradation.
        </p>
        <h1 class="heading">
          A Simple Conclusion
        </h1>
        <p>
          This chapter has repeated one theme over and over: software simplicity is a prerequisite
          to reliability. We are not being lazy when we consider how we might simplify each step of
          a given task. Instead, we are clarifying what it is we actually want to accomplish and
          how we might most easily do so. Every time we say "no" to a feature, we are not
          restricting innovation; we are keeping the environment uncluttered of distractions so
          that focus remains squarely on innovation, and real engineering can proceed.
        </p>
        <div class="footnotes">
          <p id="id-BWDujIehq">
            <sup><a href="simplicity.html#id-BWDujIehq-marker">38</a></sup>This is often true of complex systems
            in general; see <a href="bibliography.html#Per99" target=
            "_blank">[Per99]</a> and <a href="bibliography.html#Coo00" target=
            "_blank">[Coo00]</a>.
          </p>
          <p id="id-MJbuJtOhb">
            <sup><a href="simplicity.html#id-MJbuJtOhb-marker">39</a></sup>Coined by my former manager, Johan
            Anderson, around the time I became an SRE.
          </p>
          <p id="id-0vYuXSLhXCk">
            <sup><a href="simplicity.html#id-0vYuXSLhXCk-marker">40</a></sup>Protocol buffers, also referred to as
            "protobufs," are a language-neutral, platform-neutral extensible mechanism for
            serializing structured data. For more details, see <a href=
            "https://developers.google.com/protocol-buffers/docs/overview#a-bit-of-history" target=
            "_blank"><em>https://developers.google.com/protocol-buffers/docs/overview#a-bit-of-history</em></a>.
          </p>
        </div>
      </div>
    </div>
    <div class="footer">
      <div class="maia-aux">
        <div class="previous">
          <a href="release-engineering.html">
          <p class="footer-caption">
            previous
          </p>
          <p class="chapter-link">
            Chapter 8- Release Engineering
          </p></a>
        </div>
        <div class="next">
          <a href="part3.html">
          <p class="footer-caption">
            next
          </p>
          <p class="chapter-link">
            Part III - Practices
          </p></a>
        </div>
        <p class="footer-link">
          Copyright © 2017 Google, Inc. Published by O'Reilly Media, Inc. Licensed under <a href=
          "https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a>
        </p>
      </div>
    </div>
    <script src="../js/main.min.js">
    </script> 
    <script src="../js/maia.js">
    </script>
  </body>
</html>
